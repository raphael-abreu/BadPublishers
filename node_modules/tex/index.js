"use strict";
var lexing_1 = require('lexing');
var states_1 = require('./states');
function parseBibTeXEntry(string) {
    var string_iterable = new lexing_1.StringIterator(string);
    return new states_1.BIBFILE_FIRST(string_iterable, 1024).read();
}
exports.parseBibTeXEntry = parseBibTeXEntry;
function parseBibTeXEntries(string) {
    var string_iterable = new lexing_1.StringIterator(string);
    return new states_1.BIBFILE(string_iterable, 1024).read();
}
exports.parseBibTeXEntries = parseBibTeXEntries;
function parseNode(tex) {
    var string_iterable = new lexing_1.StringIterator(tex);
    // skip over the initial {
    string_iterable.skip(1);
    return new states_1.TEX(string_iterable).read();
}
exports.parseNode = parseNode;
function extractCitekeys(tex) {
    var citekeys = [];
    // super-simple regular expression solution (doesn't detect commented-out citations)
    var cite_regexp = /\\\w*cite\w*\{([^}]+)\}/g;
    var match;
    while ((match = cite_regexp.exec(tex)) !== null) {
        var match_citekeys = match[1].split(',');
        Array.prototype.push.apply(citekeys, match_citekeys);
    }
    return citekeys;
}
exports.extractCitekeys = extractCitekeys;
function stringifyBibTeXEntry(bibTeXEntry, indent, newline) {
    if (indent === void 0) { indent = '  '; }
    if (newline === void 0) { newline = '\n'; }
    var fieldLines = bibTeXEntry.fields.map(function (_a) {
        var name = _a[0], value = _a[1];
        return ("" + indent + name + " = {" + value + "},");
    });
    return "@" + bibTeXEntry.pubtype + "{" + bibTeXEntry.citekey + "," + newline + fieldLines.join(newline) + newline + "}";
}
exports.stringifyBibTeXEntry = stringifyBibTeXEntry;
function flattenBibTeXEntry(bibTeXEntry) {
    var pubtype = bibTeXEntry.pubtype, citekey = bibTeXEntry.citekey, fields = bibTeXEntry.fields;
    var object = { pubtype: pubtype, citekey: citekey };
    fields.forEach(function (_a) {
        var name = _a[0], value = _a[1];
        return object[name] = value;
    });
    return object;
}
exports.flattenBibTeXEntry = flattenBibTeXEntry;
function unflattenBibTeXEntry(object) {
    var pubtype = object.pubtype, citekey = object.citekey;
    var fields = [];
    Object.keys(object).filter(function (key) { return key != 'pubtype' && key != 'citekey'; }).forEach(function (key) {
        fields.push([key, object[key]]);
    });
    return { pubtype: pubtype, citekey: citekey, fields: fields };
}
exports.unflattenBibTeXEntry = unflattenBibTeXEntry;
